template <typename T>
void PmergeMe::fordJohnsonSort(T& container) {
    // base case
    int n = container.size();
    if (n <= 1) return;

    // Step 1: Divide into pairs and sort each pair
    std::vector<std::pair<typename T::value_type, typename T::value_type>> pairs;
    for (int i = 0; i < n - 1; i += 2)
    {
        if (container[i] > container[i + 1]) {
            pairs.push_back(std::make_pair(container[i + 1], container[i]));
        } else {
            pairs.push_back(std::make_pair(container[i], container[i + 1]));
        }
    }

    // Handling odd element
    if (n % 2 != 0) {
        pairs.push_back(std::make_pair(container[n - 1], std::numeric_limits<typename T::value_type>::max()));
    }

    PmergeMe::printPairElements(pairs);

    // Step 2: Recursively sort the 'a' elements
    T main;
    for (auto it = pairs.begin(); it != pairs.end(); ++it)
    {
        if (it->second != std::numeric_limits<typename T::value_type>::max()) {
            main.push_back(it->second);
        }
    }

    // Debugging print before recursive call
    std::cout << "main before:" << std::endl;
    printContainer(main);

    fordJohnsonSort(main);

    // Debugging print after recursive call
    std::cout << "main after:" << std::endl;
    printContainer(main);

    // Step 3: Insert 'b' elements into the main sequence using Jacobsthal order
    T pend;
    for (auto it = pairs.begin(); it != pairs.end(); ++it) {
        if (it->first != std::numeric_limits<typename T::value_type>::max()) {
            pend.push_back(it->first);
        }
    }

    // Starting from the 3rd Jacobsthal number
    int k = 3;
    int currentJ = jacobsthal(k);						// How many elements to work with so far
    int previousJ = jacobsthal(k - 1);					// How many elements have already been inserted in previous steps
    int newElementsToInsert = currentJ - previousJ; 	// The difference between current_jacobsthal and previous_jacobsthal tells you how many new elements to insert
    while (newElementsToInsert <= pend.size()) {
        int count = newElementsToInsert;
        for (int i = 0; i < count; ++i) {
            binaryInsert(main, pend.back());
            pend.pop_back();
        }
        ++k;
    }

    // Copy the sorted elements back to the original array
    for (int i = 0; i < n; ++i) {
        container[i] = main[i];
    }
}